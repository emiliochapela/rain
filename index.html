<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Rain Simulation</title>
<style>
html, body {
  margin: 0;
  height: 100%;
  background: #0b0f14;
  overflow: hidden;
}
canvas {
  display: block;
  width: 100vw;
  height: 100vh;
}

/* cinematic vignette + grain */
.overlay {
  pointer-events:none;
  position:fixed;
  inset:0;
  background:
    radial-gradient(1200px 800px at 50% 60%, rgba(255,255,255,0.05), rgba(0,0,0,0.6) 70%, rgba(0,0,0,0.8)),
    linear-gradient(to bottom, rgba(0,0,0,0.25), rgba(0,0,0,0.45));
}
.grain {
  pointer-events:none;
  position:fixed;
  inset:-30%;
  opacity:0.05;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='2'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23n)'/%3E%3C/svg%3E");
}
</style>
</head>

<body>
<canvas id="c"></canvas>
<div class="overlay"></div>
<div class="grain"></div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  let W, H, DPR;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = canvas.width  = innerWidth * DPR;
    H = canvas.height = innerHeight * DPR;
  }
  addEventListener("resize", resize);
  resize();

  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  /* ========= WEATHER REGIMES ========= */

  let intensity = 0.15;        // current rain strength
  let targetIntensity = 0.15;
  let regimeTime = 0;

  function chooseNewRegime(){
    const r = Math.random();
    if (r < 0.30) targetIntensity = rand(0.05, 0.20);     // barely raining
    else if (r < 0.65) targetIntensity = rand(0.25, 0.45);// light rain
    else if (r < 0.85) targetIntensity = rand(0.55, 0.75);// heavy rain
    else targetIntensity = rand(0.85, 1.00);              // storm

    regimeTime = rand(8, 22); // seconds per regime
  }
  chooseNewRegime();

  /* ========= BACKGROUND ========= */

  function drawBackground(exposure, fog){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, `rgb(${10+exposure*20},${12+exposure*24},${20+exposure*40})`);
    g.addColorStop(1, `rgb(${6+exposure*10},${8+exposure*14},${14+exposure*20})`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // fog layer
    ctx.fillStyle = `rgba(180,210,255,${fog})`;
    ctx.fillRect(0,0,W,H);
  }

  /* ========= RAIN ========= */

  class Drop {
    constructor(){ this.reset(true); }
    reset(randY){
      this.z = Math.pow(Math.random(),1.8);
      this.x = rand(-0.2,1.2)*W;
      this.y = randY ? rand(-1,1)*H : rand(-0.2,0)*H;

      this.lenBase = rand(10,30);
      this.speedBase = rand(600,1200);
    }

    step(dt, wind, intensity){
      const speed = (this.speedBase + intensity*2200)*(1-this.z);
      const len = (this.lenBase + intensity*70)*(1-this.z);

      this.y += speed*dt*DPR;
      this.x += wind*dt*DPR;

      this.len = len*DPR;
      this.w = (0.6 + 1.8*(1-this.z))*DPR;
      this.alpha = 0.08 + intensity*0.45;

      if(this.y-this.len>H || this.x<-0.3*W || this.x>1.3*W)
        this.reset(false);
    }

    draw(){
      ctx.lineWidth = this.w;
      ctx.lineCap = "round";
      ctx.strokeStyle = `rgba(220,240,255,${this.alpha})`;
      ctx.beginPath();
      ctx.moveTo(this.x,this.y);
      ctx.lineTo(this.x,this.y-this.len);
      ctx.stroke();
    }
  }

  let drops=[];
  function rebuild(n){
    if(drops.length<n)
      while(drops.length<n) drops.push(new Drop());
    else drops.length=n;
  }

  /* ========= LOOP ========= */

  let last=performance.now(), t=0;

  function frame(now){
    requestAnimationFrame(frame);
    const dt=Math.min(0.033,(now-last)/1000);
    last=now; t+=dt;

    // regime logic
    regimeTime-=dt;
    if(regimeTime<=0) chooseNewRegime();

    intensity += (targetIntensity-intensity)*(1-Math.pow(0.0005,dt));

    // exaggerated mappings
    const dropCount = Math.floor(80 + intensity*3000);
    const wind = (-40 + intensity*420);
    const exposure = clamp(0.45 + intensity*0.35,0.3,0.9);
    const fog = 0.08 + (1-intensity)*0.25;

    rebuild(dropCount);

    drawBackground(exposure, fog);

    ctx.save();
    ctx.globalCompositeOperation="screen";
    for(const d of drops){
      d.step(dt, wind, intensity);
      d.draw();
    }
    ctx.restore();

    // contrast curve
    ctx.save();
    ctx.globalCompositeOperation="multiply";
    ctx.fillStyle=`rgba(0,0,0,${0.15 - exposure*0.08})`;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
